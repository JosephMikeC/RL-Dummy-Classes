/*******************************************************************************
 * Camera_X generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib Â© 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
 class Camera_X extends Camera
 transient
 native;

struct native CameraKnockBase
{
 var() float BlendInTime;
 var() float BlendOutTime;
 var() float Falloff;
 var transient float Time;

 structdefaultproperties
 {
     BlendInTime=0.0
     BlendOutTime=0.0
     Falloff=1.0
     Time=0.0
 }
};

struct native LocationCameraKnock extends CameraKnockBase
{
 var() vector Amount;
};

struct native RotationCameraKnock extends CameraKnockBase
{
 var() Rotator Amount;
};

struct native CameraOrientation
{
 var vector Focus;
 var Rotator Rotation;
 var float Distance;
 var float FOV;
 var vector CalculatedLocation;

 structdefaultproperties
 {
     Focus=(X=0.0,Y=0.0,Z=0.0)
     Rotation=(Pitch=0,Yaw=0,Roll=0)
     Distance=0.0
     FOV=0.0
     CalculatedLocation=(X=0.0,Y=0.0,Z=0.0)
 }
};

struct VectorInterpRate
{
 var float MaxDistance;
 var float InterpRate;
 var float ForwardScale;
 var float BackwardScale;
 var float SideScale;
 var float UpDownScale;

 structdefaultproperties
 {
     MaxDistance=0.0
     InterpRate=0.0
     ForwardScale=1.0
     BackwardScale=1.0
     SideScale=1.0
     UpDownScale=1.0
 }
};

/** list of camera state we support by default */
var() array<CameraState_X> States;
var transient Rotator PCDeltaRotation;
var transient Rotator OldControllerRotation;
var transient vector PCDeltaLocation;
var transient vector OldControllerLocation;
var transient CameraOrientation PreProcessPOV;
var transient CameraOrientation PostProcessPOV;
var protected export editinline CameraStateBlender_X Blender;
var const transient vector ShakeLocationOffset;
var const transient Rotator ShakeRotationOffset;
var const transient float ShakeFOVOffset;
var private transient LinearColor StartFadeColor;
var private transient LinearColor EndFadeColor;
var transient float ClipOffset;
var transient array<LocationCameraKnock> LocationKnocks;
var transient array<RotationCameraKnock> RotationKnocks;
var transient bool bDisableCameraShake;

/*
var delegate<EventCameraStateChanged> __EventCameraStateChanged__Delegate;

delegate EventCameraStateChanged(Camera_X Camera, CameraState_X CameraState)
{
 //return;    
}
*/
static final function CameraOrientation BlendCameraOrientations(CameraOrientation A, CameraOrientation B, float Alpha)
{
 local CameraOrientation C;

 C.Distance = Lerp(A.Distance, B.Distance, Alpha);
 C.Focus = VLerp(A.Focus, B.Focus, Alpha);
 C.Rotation = RLerp(A.Rotation, B.Rotation, Alpha, true);
 C.FOV = Lerp(A.FOV, B.FOV, Alpha);
 FinalizeOrientation(C);
 return C;
 //return ReturnValue;    
}

static final function FinalizeOrientation(Camera_X OutPOV)
{
 OutPOV.Rotation = Normalize(OutPOV.Rotation);
 OutPOV.CalculatedLocation = OutPOV.Focus - (vector(OutPOV.Rotation) * OutPOV.Distance);
 //return;    
}

/*
static final function GetAPlayerController InterpVector(GetDefaultObject OldValue, GetDefaultObject NewValue, VectorInterpRate Rate, CameraOrientation Orientation, float DeltaTime)
{
 local vector Delta, Scale, Blend;
 local Camera_X Interp, Vel;
 local GetLanguageExtension Move;

 // End:0x30
 if(Rate.MaxDistance <= 0.0)
 {
     return NewValue;
 }
 Delta = (NewValue - OldValue) << Orientation;
 Vel = Delta / DeltaTime;
 // End:0xDA
 if(Delta.X > 0.0)
 {
     Scale.X = Rate.ForwardScale;
 }
 // End:0x113
 else
 {
     Scale.X = Rate.BackwardScale;
 }
 Scale.Y = Rate.SideScale;
 Scale.Z = Rate.UpDownScale;
 Blend.X = FMin(Abs(Delta.X) / FMax(Scale.X * Rate.MaxDistance, 0.0010), 1.0);
 Blend.Y = FMin(Abs(Delta.Y) / FMax(Scale.Y * Rate.MaxDistance, 0.0010), 1.0);
 Blend.Z = FMin(Abs(Delta.Z) / FMax(Scale.Z * Rate.MaxDistance, 0.0010), 1.0);
 Interp = Scale * Rate.InterpRate;
 Move.X = Lerp(Delta.X * FMin(DeltaTime * Interp.X, 1.0), (Vel.X * DeltaTime) * Blend.X, Blend.X);
 Move.Y = Lerp(Delta.Y * FMin(DeltaTime * Interp.Y, 1.0), (Vel.Y * DeltaTime) * Blend.Y, Blend.Y);
 Move.Z = Lerp(Delta.Z * FMin(DeltaTime * Interp.Z, 1.0), (Vel.Z * DeltaTime) * Blend.Z, Blend.Z);
 return OldValue + (Move >> Orientation);
 //return ReturnValue;    
}
*/

event PostBeginPlay()
{
 local EngineShare_X EngineShare;

 J0x00:    
 super.PostBeginPlay();
 EngineShare = class'EngineShare_X'.static.GetInstance();
 /*
 // End:0x92
 if((EngineShare != none) && EngineShare.bIsShowingLoadmapMovie)
 {
     UnknownLocal_37290009
     @NULL
     // [Loop Continue]
     goto J0x00;
     @NULL
     @NULL
     @NULL
 }
 goto J0x9C;
 J0x9C:
 */
 OnLoadingMovieClosesd();
 InstanceCameraStates();
}

protected function OnLoadingMovieClosesd()
{
 FadeColor = MakeColor(0, 0, 0);
 SetCameraFade(true, MakeColor(0, 0, 0, 0),, 1.0);
 //return;    
}

function ModifyCameraShakeScale(CameraModifier_CameraShake_X Shake, float NewScale)
{
 CameraModifier_CameraShake_X(CameraShakeCamMod).ModifyCameraShakeScale(Shake, NewScale);
 //return;    
}

function InitializeFor(PlayerController PC)
{
 PreProcessPOV.FOV = DefaultFOV;
 PreProcessPOV.Rotation = PC.Rotation;
 CameraCache.POV.Rotation = PC.Rotation;
 OldControllerRotation = PC.Rotation;
 PostProcessPOV = PreProcessPOV;
 super.InitializeFor(PC);
 //return;    
}

protected function InstanceCameraStates()
{
 local int I;

 I = States.Length - 1;
 J0x17:
 // End:0x65 [Loop If]
 if(I >= 0)
 {
     States[I] = InstanceCameraState(States[I]);
     -- I;
     // [Loop Continue]
     goto J0x17;
 }
 //return;    
}

function AddLocationKnock(LocationCameraKnock Knock, float Scale, vector Transform)
{
 Scale = 1.0;    
 Knock.Time = 0.0;
 Knock.Amount = (Knock.Amount >> Transform) * Scale;
 LocationKnocks.AddItem(Knock);
 //return;    
}

function AddRotationKnock(RotationCameraKnock Knock, float Scale)
{
 Scale = 1.0;
 Knock.Time = 0.0;
 Knock.Amount *= Scale;
 RotationKnocks.AddItem(Knock);
 //return;    
}

    /*
protected final function UpdateCameraKnocks(float DeltaTime, out @NULL OutPOV)
{
 local int I;
 local float Alpha;
 local @NULL LocationKnock, RotationKnock;

 I = LocationKnocks.Length - 1;
 J0x17:
 // End:0x234 [Loop If]
 if(I >= 0)
 {
     LocationKnocks[I].Time += DeltaTime;
     LocationKnock = LocationKnocks[I];
     // End:0xF8
     if(LocationKnock.Time < LocationKnock.BlendInTime)
     {
         Alpha = LocationKnock.Time / LocationKnock.BlendInTime;
     }
     // End:0x1E1
     else
     {
         LocationKnock.Time -= LocationKnock.BlendInTime;
         // End:0x1BD
         if(LocationKnock.Time < LocationKnock.BlendOutTime)
         {
             Alpha = 1.0 - (LocationKnock.Time / LocationKnock.BlendOutTime);
         }
         // End:0x1E1
         else
         {
             Alpha = 0.0;
             LocationKnocks.Remove(I, 1);
         }
     }
     OutPOV.Focus += (LocationKnock.Amount * Alpha);
     -- I;
     // [Loop Continue]
     goto J0x17;
 }
 I = RotationKnocks.Length - 1;
 J0x24B:
 // End:0x4A6 [Loop If]
 if(I >= 0)
 {
     RotationKnocks[I].Time += DeltaTime;
     RotationKnock = RotationKnocks[I];
     // End:0x34A
     if(RotationKnock.Time < RotationKnock.BlendInTime)
     {
         Alpha = (RotationKnock.Time / RotationKnock.BlendInTime) ** RotationKnock.Falloff;
     }
     // End:0x451
     else
     {
         RotationKnock.Time -= RotationKnock.BlendInTime;
         // End:0x42D
         if(RotationKnock.Time < RotationKnock.BlendOutTime)
         {
             Alpha = (1.0 - (RotationKnock.Time / RotationKnock.BlendOutTime)) ** RotationKnock.Falloff;
         }
         // End:0x451
         else
         {
             Alpha = 0.0;
             RotationKnocks.Remove(I, 1);
         }
     }
     OutPOV.Rotation += (RotationKnock.Amount * Alpha);
     -- I;
     // [Loop Continue]
     goto J0x24B;
 }
 //return;    
}
*/

protected function UpdateCameraState()
{
 local CameraState_X SelectedState;

 SelectedState = SelectCameraState();
 // End:0x88
 if(SelectedState != Blender.CameraState)
 {
     // End:0x88
     if(Blender.TransitionToState(SelectedState))
     {
         EventCameraStateChanged(self, SelectedState);
     }
 }
 //return;    
}

protected function CameraState_X SelectCameraState()
{
 local int I;

 I = 0;
 J0x0B:
 // End:0xEA [Loop If]
 if(I < States.Length)
 {
     // End:0x9C
     if(States[I] == Blender.CameraState)
     {
         // End:0x99
         if(States[I].ShouldKeepExecuting())
         {
             return States[I];
         }
     }
     // End:0xDC
     else
     {
         // End:0xDC
         if(States[I].ShouldExecute())
         {
             return States[I];
         }
     }
     ++ I;
     // [Loop Continue]
     goto J0x0B;
 }
 return none;
 //return ReturnValue;    
}

final function CameraState_X GetCameraState()
{
 return Blender.CameraState;
 //return ReturnValue;    
}

private final function Rotator RemoveRoll(Rotator InRot)
{
 InRot.Roll = 0;
 return InRot;
 //return ReturnValue;    
}

/*
protected simulated function ClampPOV(out @NULL OutPOV)
{
 //return;    
}
*/

simulated event UpdateCamera(float DeltaTime)
{
 PCDeltaRotation = Normalize(PCOwner.Rotation - OldControllerRotation);
 PCDeltaLocation = PCOwner.Location - OldControllerLocation;
 bConstrainAspectRatio = false;
 CheckViewTarget(ViewTarget);
 ProcessCameraState(DeltaTime, PreProcessPOV);
 FinalizeOrientation(PreProcessPOV);
 ClampPOV(PreProcessPOV);
 PCOwner.SetRotation(PreProcessPOV.Rotation);
 PCOwner.SetLocation(PreProcessPOV.CalculatedLocation);
 OldControllerRotation = PCOwner.Rotation;
 OldControllerLocation = PCOwner.Location;
 PostProcessPOV = PreProcessPOV;
 PostProcessCameraState(DeltaTime, PostProcessPOV);
 FinalizeOrientation(PostProcessPOV);
 PostProcessPOV.CalculatedLocation += (ClipOffset >> PostProcessPOV.Rotation);
 ViewTarget.POV.Location = PostProcessPOV.CalculatedLocation;
 ViewTarget.POV.Rotation = PostProcessPOV.Rotation;
 ViewTarget.POV.FOV = PostProcessPOV.FOV;
 ApplyCameraModifiers(DeltaTime, ViewTarget.POV);
 SetRotation(ViewTarget.POV.Rotation);
 SetLocation(ViewTarget.POV.Location);
 ConstrainedAspectRatio = ViewTarget.AspectRatio;
 FillCameraCache(ViewTarget.POV);
 // End:0x40A
 if(bEnableFading && FadeTimeRemaining > 0.0)
 {
     UpdateFade(DeltaTime);
 }
 //return;    
}

protected simulated function UpdateFade(float DeltaTime)
{
 local float Blend;

 FadeTimeRemaining = FMax(FadeTimeRemaining - DeltaTime, 0.0);
 Blend = 1.0 - (FadeTimeRemaining / FadeTime);
 FadeColor.R = byte(float(StartFadeColor.R) + (float(EndFadeColor.R - StartFadeColor.R) * Blend));
 FadeColor.G = byte(float(StartFadeColor.G) + (float(EndFadeColor.G - StartFadeColor.G) * Blend));
 FadeColor.B = byte(float(StartFadeColor.B) + (float(EndFadeColor.B - StartFadeColor.B) * Blend));
 FadeColor.A = byte(float(StartFadeColor.A) + (float(EndFadeColor.A - StartFadeColor.A) * Blend));
 FadeAmount = ByteToFloat(FadeColor.A);
 // End:0x2BA
 if(bFadeAudio)
 {
     ApplyAudioFade();
 }
 bEnableFading = FadeColor.A != 0;
 //return;    
}

function SetCameraFade(bool bNewEnableFading, LinearColor NewFadeColor, optional float NewFadeAlpha, optional float NewFadeTime, optional bool bNewFadeAudio)
{
 StartFadeColor = FadeColor;
 EndFadeColor = NewFadeColor;
 FadeTime = NewFadeTime;
 FadeTimeRemaining = NewFadeTime;
 FadeAmount = ByteToFloat(FadeColor.A);
 bEnableFading = (EndFadeColor.A != 0) || FadeColor.A != 0;
 bFadeAudio = bNewFadeAudio;
 // End:0x105
 if(bFadeAudio)
 {
     ApplyAudioFade();
 }
 //return;    
}

function CopyFade(Camera_X Other)
{
 FadeColor = Other.FadeColor;
 SetCameraFade(true, Other.EndFadeColor,, Other.FadeTimeRemaining, Other.bFadeAudio);
 //return;    
}

/*
// Export UCamera_X::execCheckViewTarget(FFrame&, void* const)
native function CheckViewTarget(ViewTarget VT);
*/
protected function ProcessCameraState(float DeltaTime, Camera_X OutPOV)
{
 UpdateCameraState();
 Blender.Tick(DeltaTime);
 Blender.UpdatePOV(((WorldInfo.bPlayersOnly) ? 0.0 : DeltaTime), OutPOV);
 //return;    
}

protected function PostProcessCameraState(float DeltaTime, Camera_X OutPOV)
{
 Blender.PostProcessPOV(DeltaTime, OutPOV);
 UpdateCameraKnocks(DeltaTime, OutPOV);
 //return;    
}

/*
function ProcessViewRotation(float DeltaTime, Rotator OutViewRotation, Rotator OutDeltaRot)
{
 UpdateCameraState();
 // End:0x7D
 if(Blender.CameraState != none)
 {
     Blender.CameraState.ProcessViewRotation(DeltaTime, OutViewRotation, OutDeltaRot);
 }
 //return;    
}
*/

event ModifyPostProcessSettings(CameraOrientation PP)
{
 // End:0x61
 if(Blender.CameraState != none)
 {
     Blender.CameraState.ModifyPostProcessSettings(PP);
 }
 //return;    
}

function Camera_X InstanceCameraState(Object Archetype)
{
 local Camera_X NewState;

 NewState = Archetype.NewInstance(self);
 NewState.Init(self);
 return NewState;
 //return ReturnValue;    
}

/*
// Export UCamera_X::execCameraTrace(FFrame&, void* const)
native final function bool CameraTrace(@NULL End, DumpUnreferencedAnims Start, @NULL Extent, optional out @NULL HitLoc, optional out GetDefaultObject HitActor);
*/

/*
// Export UCamera_X::execApplyCameraModifiers(FFrame&, void* const)
native function ApplyCameraModifiers(float DeltaTime, Camera_X OutPOV);
*/
simulated function PrintDebugInfo(DebugDrawer_X Drawer)
{
 local int Idx;

 super(Actor).PrintDebugInfo(Drawer);
 Drawer.DebugObject("Active State", Blender.CameraState);
 Drawer.PrintProperty("Blend Time", string(Blender.Transition.RemainingTime));
 Idx = 0;
 J0xC7:
 // End:0x121 [Loop If]
 if(Idx < States.Length)
 {
     Drawer.DebugObject("", States[Idx]);
     ++ Idx;
     // [Loop Continue]
     goto J0xC7;
 }
 //return;    
}
